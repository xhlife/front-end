
## å®¹æ˜“å¿½ç•¥çš„å…³é”®å­—

### typeof å…³é”®å­—

Typescript å¯ä»¥ä½¿ç”¨typeofå…³é”®å­—ä½œä¸ºç±»å‹ä¿æŠ¤ï¼Œ åŒæ ·çš„å’Œjsä¸€æ ·è¿˜å­˜åœ¨ instanceofã€ in ç­‰å…³é”®å­—

tsä¸­é€šè¿‡typeof ç±»å¯ä»¥è·å¾—ç±»çš„ç±»ç±»å‹ï¼Œç›´æ¥ä½¿ç”¨ç±»ä½œä¸ºç±»å‹æ­¤æ—¶ä½¿ç”¨çš„æ˜¯ç±»çš„å®ä¾‹ç±»å‹ã€‚

æ›´å¤šçš„ä¿¡æ¯: [æŸ¥çœ‹å®˜æ–¹æ–‡æ¡£https://www.typescriptlang.org/docs/handbook/2/typeof-types.html](https://www.typescriptlang.org/docs/handbook/2/typeof-types.html)
```ts
const school = "school"
let n: typeof school
// ç­‰äº let n:string

// ä¸ ReturnType å†…ç½®ç±»å‹ç»“åˆä½¿ç”¨

function f() {
  return { x: 10, y: 3 }
}
type P = ReturnType<typeof f>

//  type P = {
//     x: number;
//     y: number;
// }

```

### keyof å…³é”®å­—

keyofæ“ä½œç¬¦ä¼šå°†ä¸€ä¸ªå¯¹è±¡ç±»å‹(æ³¨æ„è¿™é‡Œæ˜¯ç±»å‹å¹¶ä¸æ˜¯å€¼)çš„keyç»„æˆè”åˆç±»å‹è¿”å›ã€‚ 

æœ‰ç‚¹ Object.keys(obj) çš„æ„æ€ï¼Œåªä¸è¿‡è¦å…³æ³¨çš„æ˜¯ï¼Œè¿™é‡Œæ˜¯å–å‡ºæ‰€æœ‰çš„keyåšè”åˆï¼ˆa | b | cï¼‰

```ts
type ArrayIsh = { [n: number]: unknown };
type A = keyof ArrayIsh;
    
// type A = number
 
type MapIsh = { [k: string]: boolean };
type M = keyof MapIsh;
    
// type M = string | number
```

 è€Œ keyof ä¸ in å…³é”®å­—ç»„åˆèµ·æ¥ï¼Œå°±å¯ä»¥å¤åˆ¶ä¸€ä¸ªç±»å‹(é¢ï¼Œåªæ˜¯ä¸ºäº†æ¼”ç¤ºï¼Œå®é™…å¼€å‘å¤§å¯ä¸å¿…)

 ```ts
interface Test {
  t: string
  k: number
}
type Copy<T> = {
  [K in keyof T]: T[K]
}

type CopyTest = Copy<Test>

const fff: CopyTest = {
  t: "1",
  k: 1
}
 ```


### extends å…³é”®å­—

Tsä¸­extendsé™¤äº†ç”¨åœ¨ç»§æ‰¿ä¸Šï¼Œè¿˜å¯ä»¥è¡¨è¾¾æ³›å‹çº¦æŸï¼Œé€šè¿‡extendså…³é”®å­—å¯ä»¥çº¦æŸæ³›å‹å…·æœ‰æŸäº›å±æ€§ã€‚

```ts
function loggingIdentity<T>(arg: T): T {
  console.log(arg.length) // Tsè¯­æ³•é”™è¯¯ Tå¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œå¹¶ä¸å­˜åœ¨lengthå±æ€§
  return arg
}

// é‡‡ç”¨ä¸‹é¢çš„æ–¹å¼
interface Lengthwise {
  length: number
}

// è¡¨ç¤ºä¼ å…¥çš„æ³›å‹Tæ¥å—Lengthwiseçš„çº¦æŸ
// Tå¿…é¡»å®ç°Lengthwise æ¢å¥è¯è¯´ Lengthwiseè¿™ä¸ªç±»å‹æ˜¯å®Œå…¨å¯ä»¥èµ‹ç»™T
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length) // OK
  return arg
}

// å—æ³›å‹çº¦æŸ
loggingIdentity(3);  // Error
loggingIdentity({length: 10, value: 3}) // OK

// ğŸŒ°  è·å– obj[key]

function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}

const x = {a: "zz", b: 2, c: 3, d: {test: 1}}

getProperty(x, "a") // okay
getProperty(x, "e") // error
```
### inferï¼ˆæ¨æ–­çš„æ„æ€ï¼‰ å…³é”®å­—

è¡¨ç¤ºåœ¨ extends æ¡ä»¶è¯­å¥ä¸­ `å¾…æ¨æ–­çš„ç±»å‹å˜é‡`ï¼Œ å¿…é¡»è”åˆ extends å‡ºç°

æ³¨æ„âš ï¸ï¼š infer è·Ÿéš extends æˆå¯¹å‡ºç°ï¼Œ infer è¡¨ç¤ºå¾…æ¨æ–­

ä½¿ç”¨
```ts
type ParamType<T> = T extends (...args: infer P) => any ? P : T;

interface User {
  name: string;
  age: number;
}

type Func = (user: User) => void;

type Param = ParamType<Func>; // Param = User
type AA = ParamType<string>; // string

```




## å†…ç½®ç±»å‹

### partial éƒ¨åˆ†çš„ï¼Œ å±€éƒ¨çš„

ä½œç”¨ï¼š å°†å¯¹è±¡çš„ç¬¬ä¸€å±‚å±æ€§è½¬ä¸ºå¯é€‰çš„

å¦‚æœæœ‰å¾ˆå¤šå±æ€§æ ‘éå¿…éœ€çš„ï¼Œé‚£ä¹ˆå¯ä»¥é‡‡ç”¨è¿™ä¸ªä¸€æ¬¡æ€§å…¨éƒ¨è½¬äº†

æ ¹æ®è¿™ä¸ªæè¿°ï¼Œå…¶å®partialçš„åŸç†éå¸¸çš„ç®€å•

```ts
type Partial<OBJ> = {
  [key in keyof OBJ]?: OBJ[key]
}
```


```ts
interface Coord = {
  x: number,
  y: number,
  obj: {
    t: string
  }
}

type Coord2 = partial<Coord>

// ç­‰åŒäº

interface Coord3 {
  x?: number | undefined,
  y?: number | undefined,
  obj?: { t: string} | undefined
}

// å¦‚æœæƒ³é€’å½’çš„å°†å±æ€§è½¬ä¸ºå¯é€‰, é‚£ä¹ˆå¯ä»¥è¿™æ ·
interface Person {
  name: string
  age: number
  detail: {
    school: string
    company: string
  }
}
type DeepPartial<T> = {
  // åˆ¤æ–­ T[K] æ˜¯å¦æ˜¯å¯¹è±¡ï¼Œ æ˜¯çš„è¯é€’å½’
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K]
}
type DPerson = DeepPartial<Person>

```

### Required

Requiredå…¨éƒ¨çš„æ„æ€ï¼Œ åœ¨ts ä¸­è¡¨ç¤ºå°† å…¨éƒ¨çš„å±æ€§è½¬ä¸ºå¿…é€‰çš„ã€‚ ä¸Partial æ„æ€åˆšå¥½ç›¸åï¼ŒåŒæ ·ä¸æ”¯æŒæ·±å±‚å±æ€§ï¼Œéœ€è¦é€’å½’ã€‚

```ts
type Req<T> = {
  [K in keyof T]-?: T[K]
}
```

`-?` ä»€ä¹ˆä¸œè¥¿ï¼Ÿ

æ²¡é”™ï¼Œ æ­£æ˜¯é€šè¿‡åœ¨å±æ€§åé¢é‡‡ç”¨ -? å®šä¹‰å±æ€§ä¸ºå¿…å¡«çš„ã€‚
 
å¯¹äºæ·±å±‚çš„å±æ€§ï¼ŒåŒæ ·çš„é‡‡ç”¨é€’å½’çš„æ–¹å¼æ¥å®ç°

```ts
type DeepRequired<T> = {
  [K in keyof T]-?: T[K] extends object ? DeepRequired<T[K]> : T[K];
}
```
ä¾‹å­ä¸ä¸¾äº†

### Exclude<T,U>

æ’é™¤ T ç±»å‹ä¸­æ»¡è¶³ U çš„ç±»å‹ä»è€Œè¿”å›æ–°çš„ç±»å‹ã€‚ ä¸»è¦æ˜¯é’ˆå¯¹äº è”åˆç±»å‹`(string|number|array)`æ¥æ“ä½œã€‚

ç®€å•è¯´å°±æ˜¯ï¼š æ’é™¤ T ä¸­åŒ…å«çš„ U éƒ¨åˆ†ï¼Œ è¿”å› å‰©ä¸‹æ²¡æ’é™¤çš„ã€‚

```ts
let a: string | number; // éœ€è¦é‡‡ç”¨ let  å› ä¸º type a çš„è¯ï¼Œ ä¸‹é¢çš„ typeof a å°±è¯†åˆ«ä¸äº†

// æ’é™¤  typeof a => [string, number] ä¸­çš„ string , å› æ­¤å‰©ä¸‹  number
type CustomType = Exclude<typeof a, string>; // number ç±»å‹
```

åŸç†å®ç°: æ³›å‹ é…åˆ extend å·²ç»æ¡ä»¶è¿ç®—ç¬¦

```ts
type Exclude<T, U> = T extends U ? never : T

// never ä»£è¡¨çš„ä¹Ÿå°±æ˜¯ä¸€ä¸ªæ— æ³•è¾¾åˆ°çš„ç±»å‹ï¼Œä¸ä¼šäº§ç”Ÿä»»ä½•çš„æ•ˆæœï¼Œè‡ªç„¶å°±ä¼šè¢«å¿½ç•¥
```

### Extract<T,U> 
extract çš„å«ä¹‰ä¸ exclude ç›¸åï¼Œ ä»–ä¼šæŒ‘å‡º T ä¸­ç¬¦åˆ U çš„ç±»å‹ï¼Œ è€Œéæ’é™¤
```ts
let a: string | number; 
type CC = Extract<typeof a, number | Array<number>>
const c: CC = [12]
```

### Pick<Type,Keys> å…³é”®å­—
pickï¼š æŒ‘é€‰çš„æ„æ€

ä» typeä¸­æŒ‘é€‰å‡º keys, ä»è€Œè¿”å›æ–°çš„ç±»å‹

```ts
interface Props {
  name: string,
  label: number,
  value: boolean
}
type ChildrenProps = Pick<Props, 'name' | 'label'> // {name: string, label: number}
```
åŸç†å®ç°
```ts
type Pick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

### Parameters<T,>

Parameters<T,>  ç”¨äºè·å–å‡½æ•°çš„å‚æ•°ç±»å‹ç»„æˆçš„`å…ƒç»„ç±»å‹[a:string, b:number]`

```ts
const fn = (a:string, b: number, ...c: number[]) => {}

type c = Parameter<typeof fn>
// c [a:string, b: number, ...c:number[]]
```

æºç å®ç°ï¼š 
```ts
type Parameters<T extends (...args:any) => any> = T extends (args: infer P) => any ? P : never
```

### Omit<T,K> å…³é”®å­—
omit: å¿½ç•¥çš„æ„æ€

ä»å¦ä¸€ä¸ªå¯¹è±¡ç±»å‹ä¸­å‰”é™¤æŸäº›å±æ€§ï¼Œå¹¶åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ç±»å‹ã€‚

```ts
type User = {
  id: string,
  name: string,
  email: string
}

type UserWithoutEmail = Omit<User, 'email'>

// å‰”é™¤äº† email è¿™ä¸ªå±æ€§ï¼Œ å› æ­¤ç­‰ä»·äºä¸‹é¢çš„

type UserWithoutEmail = {
  id: string,
  name: string
}
```

### ReturnType<T,>

æ¥å—ä¼ å…¥ä¸€ä¸ªå‡½æ•°ç±»å‹ä¸ºæ³›å‹ï¼Œè¿”å›å€¼ä¸ºå‡½æ•°çš„è¿”å›ç±»å‹

```ts
type T0 = ReturnType<() => string>; // type T0 = string

type T1 = ReturnType<(s: string) => void>; // type T1 = void
```


### Record<Keys,type> å…³é”®å­—

æ„é€ ä¸€ä¸ªæ–°çš„å¯¹è±¡ç±»å‹ï¼Œå…¶å±æ€§é”®ä¸ºKeys(è”åˆç±»å‹)ï¼Œå±æ€§å€¼ä¸ºTypeã€‚

```ts
type keys = 'name' | 'title' | 'hello'

interface value {
  name: string,
  label?: number
}

// Record å†…ç½®ç±»å‹ï¼Œå¯ä»¥å°†ä¼ å…¥çš„ keys è”åˆç±»å‹éå†ä½œä¸º key 
// ä¸ºæ¯ä¸€ä¸ªkey çš„valueèµ‹å€¼ ä¸º values ä»è€Œå½¢æˆä¸€ä¸ªå…¨æ–°çš„å¯¹è±¡ç±»å‹è¿”å›

// éå† keys => name | title | hello , ç”Ÿæˆ name = value, title = value, hello = value

// è€Œ value = {name: string, label?: number}
const b: Record<keys, value> = {
  name: {
    name: 'ww',
    label: 1
  },
  title: {
    name: 'ls',
    label: 2
  },
  hello: {
    name: 'zs'
  }
}


// è€Œ Record å¸¸ç”¨äº éå†å¯¹è±¡è¿”å›æ–°çš„ç±»å‹æ—¶ä½¿ç”¨
function mapping<K extends string | number | symbol, V, R>(
  obj: Record<K, V>,
  callback: (key: K, value: V) => R
): Record<K, R> {
  const result = {} as Record<K, R>
  Object.keys(obj).forEach(key => {
    const parseKey = key as K
    const value = obj[parseKey]
    result[parseKey] = callback(parseKey, value)
  })
  return result
}

mapping({name: "19", company: "Tc"}, (key, value) => {
  return key + value
})

```


æ€»ç»“ï¼š ts å†…ç½®å…³é”®å­—ï¼Œå…¶å®åŸºæœ¬å°±æ˜¯ äº¤é›†å’Œå¹¶é›† çš„æ¦‚å¿µï¼Œæ ¹æ®è‹±è¯­å•è¯çš„å­—é¢æ„æ€ä¹Ÿå¯ä»¥çŒœå‡ºå…¶ä½œç”¨ï¼Œ è€Œå…¶ä¸­ä¹Ÿæœ‰ä¸€äº›ç‰¹æ®Šçš„ï¼Œéœ€è¦è®°å¿†ä¸€ä¸‹ã€‚










